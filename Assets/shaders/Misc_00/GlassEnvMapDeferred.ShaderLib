FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

RENDER_STATE RSC_0 {
  trackingmask = 256;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 100;
  srcblend = src_alpha;
  dstblend = one_minus_src_alpha;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------
  rst_flags = 1;
  cullmode = none;

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  trackingmask = 512;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 100;
  srcblend = src_alpha;
  dstblend = one_minus_src_alpha;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------
  rst_flags = 1;
  cullmode = none;

  //------ Tesselation State Group ------
}

SHADER GlassEnvMap {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 551;
  perprimitive_callback = "OnEffectRangeCallback";
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 2;
  SAMPLER_PS 0 = {
    samplername = "";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,0.000000;
    minlod = 0.000000;
    maxlod = 1024.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "";
    texturetype = custom;
    textureindex = 0;
    texturefile = "Textures\Effects\smoke01.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,0.000000;
    minlod = 0.000000;
    maxlod = 1024.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
//
//#include <Shaders/VisionCommon.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4 mMVP : packoffset(c4);   // model view projection matrix
  float4x4 mMVM : packoffset(c0);
}
#else
  float4x4 mMVP : register(c8);
  float4x4 mMVM : register(c0);
#endif



float2 sphereMap(float4 ObjPos, float3 Normal, float4x4 mMV)
{
  float4 u = -mul( mMV, ObjPos );
  u = normalize(u);
  float4 n;
  n.xyz = -mul( (float3x3)mMV, Normal );
  n.w = 0.0f;
  float4 r = u - 2.0f * dot(n, u) * n;
  float p = sqrt(r.x*r.x + r.y*r.y + (r.z+1.0f)*(r.z+1.0f));
  float2 SphMap;
  SphMap.x = r.x / (2.0f * p) + 0.5f;
  SphMap.y = r.y / (2.0f * p) + 0.5f;
  return SphMap;
}

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  float2 UV0 : TEXCOORD0;
};                                           

struct VS_OUT                                 
{                                             
  float4 ProjPos  : POSITION;              
  float2 UV0 : TEXCOORD0;
  float2 UV1 : TEXCOORD1;
};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out;                                
  Out.ProjPos = mul( mMVP, float4(In.ObjPos, 1.0f) );  
  
Out.ProjPos = float4(1.0f, 1.0f, 1.0f, 1.0f);  
  Out.UV0 = In.UV0;
  Out.UV1 = sphereMap(float4(In.ObjPos, 1.0f), In.Normal, mMVM);
  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_2_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_2_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>

#ifdef _VISION_DX11
  Texture2D <float4> BaseTexture        : register(t0);
  sampler            BaseTextureSampler : register(s0);
  Texture2D <float4> EnvMap             : register(t1);
  sampler            EnvMapSampler      : register(s1);
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    float4             Color              : packoffset(c0);
  }
#else
  sampler2D          BaseTexture        : register(s0);
  sampler2D          EnvMap        : register(s1);
  #if defined(_VISION_PS3) || defined(_VISION_WIIU)
    float4             Color              : register(c32);
  #else  
    float4             Color;
  #endif
#endif

struct PS_IN
{                  
  float4 ProjPos  : POSITION;              
  float2 UV0 : TEXCOORD0;
  float2 UV1 : TEXCOORD1;
};
   
float4 ps_main( PS_IN In ) : SV_Target
{
  float4 color = vTex2D(BaseTexture, BaseTextureSampler, In.UV0);
  color.xyz *= vTex2D(EnvMap, EnvMapSampler, In.UV1).xyz;
  color.xyz *= 2.0f * Color.xyz;
  return color;
}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_2_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_4_0;

  //------ platform specific bytecode ------
}

SHADER SimpleGlass {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 551;
  perprimitive_callback = "OnEffectRangeCallback";
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,0.000000;
    minlod = 0.000000;
    maxlod = 1024.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4 mMVP : packoffset(c4);   // model view projection matrix
  float4x4 mMVM : packoffset(c0);
}
#else
  float4x4 mMVP : register(c8);
  float4x4 mMVM : register(c0);
#endif



float2 sphereMap(float4 ObjPos, float3 Normal, float4x4 mMV)
{
  float4 u = -mul( mMV, ObjPos );
  u = normalize(u);
  float4 n;
  n.xyz = -mul( (float3x3)mMV, Normal );
  n.w = 0.0f;
  float4 r = u - 2.0f * dot(n, u) * n;
  float p = sqrt(r.x*r.x + r.y*r.y + (r.z+1.0f)*(r.z+1.0f));
  float2 SphMap;
  SphMap.x = r.x / (2.0f * p) + 0.5f;
  SphMap.y = r.y / (2.0f * p) + 0.5f;
  return SphMap;
}

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  float2 UV0 : TEXCOORD0;
};                                           

struct VS_OUT                                 
{                                             
  float4 ProjPos  : SV_Position;              
  float2 UV0 : TEXCOORD0;
};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out;                                
  Out.ProjPos = mul( mMVP, float4(In.ObjPos, 1.0f) );  
  Out.UV0 = In.UV0;
  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_2_0;
  vs_mintargetDX11 = vs_4_0_level_9_1;
  svs_mintarget = vs_2_0;
  svs_mintargetDX11 = vs_4_0_level_9_1;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>

#ifdef _VISION_DX11
  Texture2D <float4> BaseTexture        : register(t0);
  sampler            BaseTextureSampler : register(s0);
  Texture2D <float4> EnvMap             : register(t1);
  sampler            EnvMapSampler      : register(s1);
  cbuffer g_GlobalConstantBufferUser : register (b2)
  {
    float4             Color              : packoffset(c0);
  }
#else
  sampler2D          BaseTexture        : register(s0);
  sampler2D          EnvMap        : register(s1);
  #if defined(_VISION_PS3) || defined(_VISION_WIIU)
    float4             Color              : register(c32);
  #else  
    float4             Color;
  #endif
#endif

struct PS_IN
{                  
  float4 ProjPos  : SV_Position;              
  float2 UV0 : TEXCOORD0;
};
   
float4 ps_main( PS_IN In ) : SV_Target
{
  float4 color = vTex2D(BaseTexture, BaseTextureSampler, In.UV0);
  color *= 2.0f * Color;
  return color;
}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_2_0;
  ps_mintargetDX11 = ps_4_0_level_9_1;

  //------ compute shader source ------
  cs_mintarget = cs_4_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT GlassEnvMap {
  DESCRIPTION = {};
  PARAMCOMMENT={"EnvMap","Spherical environment map texture","Textures\Effects\smoke01.dds",texture,texturefile,""};
  PARAMCOMMENT={"Color","","1,1,1,1",float4,color,""};
  TECHNIQUE "default"
  {
    passes="GlassEnvMap";
    passtype = TransparentPass;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT SimpleGlass {
  DESCRIPTION = {};
  PARAMCOMMENT={"Color","","1,1,1,1",float4,color,""};
  TECHNIQUE "new_technique"
  {
    passes="SimpleGlass";
    passtype = TransparentPass;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

